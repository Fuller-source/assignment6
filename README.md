[Repo Link](https://github.com/Fuller-source/assignment6.git)

The traditional approach involved a learning curve but offered more control. Using the codegen tool provided a solid foundation, but translating the full, complex test case into Java code required careful implementation of the Playwright API, managing locators, and manually structuring assertions. The AI-assisted approach had a different kind of learning curve. While the writing was as simple as providing natural language prompts, the initial setup to configure the MCP server in VS Code was a trivial hurdle. Once set up, generating the first draft of the test script was incredibly fast. However, refining the prompt to get the AI to produce a test case applicable to the website was an iterative process, much like debugging code.

Writing the code myself, accuracy was a direct result of my own effort. The code was reliable because I wrote and debugged each section myself. The AI-generate tests were also accurate on the first pass but were not exactly complete. The AI generated code did not include critical setup requirements from the assignment, such as the code for the video recording. This meant the generated code was a head start that still required a human developer to review, correct, and augment to meet all specifications.

For maintenance, I feel like the code I wrote myself is inherently more maintainable. I am familiar with the structure, the variable names, and the logic of each test. If a website element changes, I know exactly where to look in the code to make the fix. The AI-generated code, while functional, felt more “black-box.” Although it was written in Java, I did not go through the process of creating it, which made me less familiar with its flow. I also encountered limitations in the AI’s ability to understand the full context, requiring me to break down the test case into smaller, sequential prompts.

Overall, the AI-assisted approach is a powerful tool for accelerating the initial creation of a test, but it is not a replacement for a human developer. It functions best as an assistant, generating boilerplate code that a developer must then validate, complete, and maintain. The traditional approach, while slower to start, results in code that is more understandable to me, leading to more confidence in its reliability and easier long-term maintenance.
